{"description_en":"# Misc demos\n\nHere you can see different things that this editor is allows:\n- Teleportation of matrix: view matrix `tri2`.\n- Custom `is_inside` functions, you can see this for triangle and round portals.\n- Complex objects, like sphere is can be set by glsl code.\n- Complex object can be portal, like mobius portal.\n- Reflection material in wall.\n- Refraction material in sphere.","description_ru":"","uniforms":{"names":["a"],"storage":[{"Formula":"sin(pi())"}]},"matrices":{"names":["id","a","b","p1","p2","p3","p4","p5","p6","tri","tri2","sph","mob1","mob2"],"storage":[{"Simple":{"offset":[0.0,0.0,0.0],"scale":1.0,"rotate":[0.0,0.0,0.0],"mirror":[false,false,false]}},{"Simple":{"offset":[0.0,0.0,-3.0],"scale":1.0,"rotate":[0.0,0.0,0.0],"mirror":[false,false,false]}},{"Simple":{"offset":[0.0,0.0,3.0],"scale":1.0,"rotate":[0.0,0.0,0.0],"mirror":[false,false,false]}},{"Simple":{"offset":[0.0,0.0,4.0],"scale":1.0,"rotate":[0.0,0.0,0.0],"mirror":[false,false,false]}},{"Simple":{"offset":[0.0,0.0,-4.0],"scale":1.0,"rotate":[0.0,0.0,0.0],"mirror":[false,false,false]}},{"Simple":{"offset":[0.0,4.0,0.0],"scale":1.0,"rotate":[1.5707964,0.0,0.0],"mirror":[false,false,false]}},{"Simple":{"offset":[0.0,-4.0,0.0],"scale":1.0,"rotate":[1.5707964,0.0,0.0],"mirror":[false,false,false]}},{"Simple":{"offset":[4.0,0.0,0.0],"scale":1.0,"rotate":[0.0,1.5707964,0.0],"mirror":[false,false,false]}},{"Simple":{"offset":[-4.0,0.0,0.0],"scale":1.0,"rotate":[0.0,1.5707964,0.0],"mirror":[false,false,false]}},{"Simple":{"offset":[0.0,0.0,2.73],"scale":1.0,"rotate":[1.5707964,0.0,0.0],"mirror":[false,false,false]}},{"Teleport":{"first_portal":"b","second_portal":"a","what":"tri"}},{"Simple":{"offset":[0.0,0.37,0.0],"scale":1.1,"rotate":[0.0,0.0,0.0],"mirror":[false,false,false]}},{"Simple":{"offset":[2.5,0.0,0.0],"scale":1.0,"rotate":[0.0,0.0,1.5707964],"mirror":[false,false,false]}},{"Simple":{"offset":[-2.5,-0.0,0.0],"scale":1.0,"rotate":[0.0,0.0,1.5707964],"mirror":[false,false,false]}}]},"objects":{"names":["0","1","2","3","4","5","6","7","8","9","10"],"storage":[{"Flat":{"kind":{"Simple":"p1"},"is_inside":"return is_inside_square(x, y, green_M);"}},{"Flat":{"kind":{"Simple":"p2"},"is_inside":"return is_inside_square(x, y, red_M);"}},{"Flat":{"kind":{"Simple":"p3"},"is_inside":"return is_inside_square(x, y, black_M);"}},{"Flat":{"kind":{"Simple":"p4"},"is_inside":"return is_inside_square(x, y, gray_M);"}},{"Flat":{"kind":{"Simple":"p5"},"is_inside":"return is_inside_square(x, y, gray_M);"}},{"Flat":{"kind":{"Simple":"p6"},"is_inside":"return is_inside_square(x, y, black_M);"}},{"Flat":{"kind":{"Simple":"tri"},"is_inside":"if ((b_mat_inv * pos).z > 0.) return NOT_INSIDE;\n\nreturn is_inside_triangle(x, y, 2.0, 0.6, 0.05, black_solid_M, white_solid_M);"}},{"Flat":{"kind":{"Simple":"tri2"},"is_inside":"if ((a_mat_inv * pos).z < 0.) return NOT_INSIDE;\n\nreturn is_inside_triangle(x, y, 2.0, 0.6, 0.05, black_solid_M, white_solid_M);"}},{"Flat":{"kind":{"Portal":["a","b"]},"is_inside":"float pos1 = x*x + y*y;\nif (pos1 < 1.) {\n  if (back) {\n    if (first) {\n      return blue_M;\n    } else {\n      return orange_M;\n    }\n  } else {\n    return TELEPORT;\n  }\n} else if (pos1 < 1.1) {\n  if (first) {\n    return blue_M;\n  } else {\n    return orange_M;\n  }\n} else {\n  return NOT_INSIDE;\n}"}},{"Complex":{"kind":{"Simple":"sph"},"intersect":"vec3 op = -r.o.xyz;\nfloat b = dot(op, r.d.xyz);\nfloat det = b*b - dot(op, op) + 1.0;\nif (det < 0.) return scene_intersection_none;\n\ndet = sqrt(det);\nfloat t = b - det;\nif (t < 0.) t = b + det;\nif (t < 0.) return scene_intersection_none;\n\nvec4 pos = r.o + r.d * t;\nvec3 n = normalize(pos.xyz);\n\nfloat u = atan(pos.z, pos.x);\nfloat v = atan(sqrt(pos.x * pos.x + pos.z * pos.z), pos.y);\n\nreturn SceneIntersection(sphere_M, SurfaceIntersection(true, t, u, v, n));"}},{"Complex":{"kind":{"Portal":["mob1","mob2"]},"intersect":"SurfaceIntersection hit =  mobius_intersect(r);\nint material = green2_M;\nif (first) {\n  material = orange_M;\n} else {\n  material = blue_M;\n}\nif (abs(hit.v) < 0.9) {\n  material = TELEPORT;\n}\nreturn SceneIntersection(material, hit);"}}]},"textures":{"names":[],"storage":[]},"materials":{"names":["black","green","red","gray","black_solid","white_solid","blue","orange","sphere","green2"],"storage":[{"Simple":{"color":[0.054903064,0.054903064,0.054903064],"normal_coef":0.5,"grid":true,"grid_scale":1.0,"grid_coef":0.3}},{"Reflect":{"add_to_color":[1.0,1.0,1.0]}},{"Simple":{"color":[0.5669161,0.037726384,0.037726384],"normal_coef":0.5,"grid":true,"grid_scale":1.0,"grid_coef":0.3}},{"Simple":{"color":[0.3473362,0.3473362,0.3473362],"normal_coef":0.5,"grid":true,"grid_scale":1.0,"grid_coef":0.3}},{"Simple":{"color":[0.0,0.0,0.0],"normal_coef":0.5,"grid":false,"grid_scale":4.0,"grid_coef":0.3}},{"Simple":{"color":[0.7032436,0.7032436,0.7032436],"normal_coef":0.5,"grid":false,"grid_scale":4.0,"grid_coef":0.3}},{"Simple":{"color":[0.05806269,0.7189187,0.9494929],"normal_coef":0.5,"grid":false,"grid_scale":4.0,"grid_coef":0.3}},{"Simple":{"color":[0.8128055,0.19476937,0.04093266],"normal_coef":0.5,"grid":false,"grid_scale":4.0,"grid_coef":0.3}},{"Refract":{"refractive_index":1.5,"add_to_color":[1.0,1.0,1.0]}},{"Simple":{"color":[0.09210875,0.72849244,0.06813221],"normal_coef":0.5,"grid":true,"grid_scale":4.0,"grid_coef":0.3}}]},"library":{"names":["my library","mobius"],"storage":["int is_inside_square(float x, float y, int material) {\n  if (abs(x) < 4. && abs(y) < 4.) {\n    return material;\n  } else {\n    return NOT_INSIDE;\n  }\n}\n\nint is_inside_triangle(float x, float y, float angle, float width, float border, int inner_m, int border_m) {\n  float value = width - abs(x)*angle;\n  if (y > border && abs(y) < value) {\n    return inner_m;\n  } else if (y > 0. && abs(y) < value + border*angle) {\n    return border_m;\n  } else {\n    return NOT_INSIDE;\n  }\n}\n","vec2 two_lines_nearest_points(Ray a, Ray b) {\n    vec3 n = cross(a.d.xyz, b.d.xyz);\n    vec3 n1 = cross(a.d.xyz, n);\n    vec3 n2 = cross(b.d.xyz, n);\n    return vec2(\n        dot(b.o.xyz-a.o.xyz, n2)/dot(a.d.xyz, n2),\n        dot(a.o.xyz-b.o.xyz, n1)/dot(b.d.xyz, n1)\n    );\n}\n\nfloat project(vec3 a, vec3 to) {\n    return dot(a, to) / dot(to, to);\n}\n\nvec3 projection(vec3 a, vec3 to) {\n    return to * project(a, to);\n}\n\nfloat clamp_mod(float a, float max) {\n    a = max + mod(a, max);\n    if (a < 0.) {\n        a += max;\n    }\n    if (a > max) {\n        a -= max;\n    }\n    return a;\n}\n\nfloat clamp_angle(float a) {\n    return clamp_mod(a, 2. * PI);\n}\n\nvec3 mobius_o(float u) {\n    return vec3(cos(u), 0, sin(u));\n}\n\nvec3 mobius_d(float u) {\n    return vec3(cos(u/2.)*cos(u), sin(u/2.), cos(u/2.)*sin(u))/2.; // mobius\n}\n\nvec3 mobius_step(float u, Ray r) {\n    Ray l = Ray(vec4(mobius_o(u), 1.), vec4(mobius_d(u), 0.));\n    vec2 ts = two_lines_nearest_points(l, r);\n\n    vec3 lnearest = (l.o + l.d * ts.x).xyz;\n    vec3 rnearest = (r.o + r.d * ts.y).xyz;\n    \n    float distance = length(lnearest - rnearest);\n\n    if (abs(ts.x) > 1.) {\n        distance *= 2. * abs(ts.x);\n    }\n\n    if (ts.y < 0.) {\n        distance *= 4. * abs(ts.y);\n    }\n\n    return vec3(distance, ts.x, ts.y); // distance, v, t\n}\n\nvec3 mobius_d1(float v, float u) {\n    float a = sin(u/2.);\n    float b = cos(u/2.);\n    float c = sin(u);\n    float d = cos(u);\n    return vec3(\n        b*d/2., \n        b*c/2., \n        a/2.\n    );\n}\n\nvec3 mobius_d2(float v, float u) {\n    float a = sin(u/2.);\n    float b = cos(u/2.);\n    float c = sin(u);\n    float d = cos(u);\n    return vec3(\n        -(0.25*v*a*d+0.5*v*c*b+c), \n        -(0.25*(v*a*c-2.*d*(v*b+2.))), \n        0.25*v*b\n    );\n}\n\nstruct SearchResult {\n    float t;\n    float u;\n    float v;\n};\n\nSearchResult mobius_best_approx(float u, Ray r, float eps_newton, SearchResult best) {\n    float eps_der = 0.0001;\n\n    vec3 step = mobius_step(u, r);\n    for (int k = 0; k < 10; k++) {\n        if (step.x < eps_newton) {\n            break;\n        }\n        float du = -step.x/(mobius_step(u + eps_der, r).x - step.x)*eps_der;\n        u = clamp_angle(u + du);\n        step = mobius_step(u, r);\n        if (best.t > 0. && abs(u-best.u) < 0.01) {\n            return SearchResult(-1., 0., 0.);\n        }\n    }\n\n    if (step.x < eps_newton) {\n        return SearchResult(step.z, u, step.y);    \n    } else {\n        return SearchResult(-1., 0., 0.);\n    }\n}\n\nSearchResult update_best_approx(SearchResult best, SearchResult current) {\n    if (current.t > 0. && (current.v > -1. && current.v < 1.)) {\n        if (best.t < 0.) {\n            best = current;\n        } else {\n            if (current.t < best.t) {\n                best = current;\n            }\n        }\n    }\n    return best;\n}\n\nSearchResult mobius_find_best(Ray r) {\n    SearchResult best = SearchResult(-1., 0., 0.);\n    best = update_best_approx(best, mobius_best_approx(0., r, 0.0001, best));\n    best = update_best_approx(best, mobius_best_approx(PI, r, 0.0001, best));\n    for (int i = 0; i < 2; i++) {\n        float u = float(i*2 + 1)/4. * 2. * PI;\n        best = update_best_approx(best, mobius_best_approx(u, r, 0.0001, best));\n    }\n    for (int i = 0; i < 4; i++) {\n        float u = float(i*2 + 1)/8. * 2. * PI;\n        best = update_best_approx(best, mobius_best_approx(u, r, 0.0001, best));\n    }\n    if (best.t < 0.) {\n        return best;\n    }\n    best = update_best_approx(best, mobius_best_approx(float(8 - 1)/16. * 2. * PI, r, 0.0001, best));\n    best = update_best_approx(best, mobius_best_approx(float(8 + 1)/16. * 2. * PI, r, 0.0001, best));\n    return best;\n}\n\nbool intersect_mobius_sphere(Ray r) {\n    vec3 op = -r.o.xyz;\n    float b = dot(op, r.d.xyz);\n    float det = b * b - dot(op, op) + 2.4055; // 1.55Â²\n    return det >= 0.;\n}\n\nSurfaceIntersection mobius_intersect(Ray r) {\n    if (intersect_mobius_sphere(r)) {\n        SearchResult best = mobius_find_best(r);\n        if (best.t >= 0.) {\n            vec3 normal = normalize_normal(cross(mobius_d1(best.v, best.u), mobius_d2(best.v, best.u)), r.d.xyz);\n            return SurfaceIntersection(true, best.t, best.u, best.v, normal);\n        }\n    }\n\n    return intersection_none;\n}"]},"user_uniforms":{"uniforms":[false]},"animation_stages":{"names":["Main"],"storage":[{"uniforms":["Remains"]}]},"current_stage":0}